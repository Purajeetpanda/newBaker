<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Minimal, Honest Sourdough — Self‑Healing (3D Loaf)</title>
  <meta name="description" content="From-scratch sourdough guide. If any picture fails, a 3D sourdough loaf is rendered on‑the‑fly with WebGL and used as a fallback. Regenerate appears only after a failure." />
  <style>
    :root { --bg:#0b0f14; --card:#121821; --ink:#e8eef5; --muted:#9fb1c2; --line:#1d2836; --shadow:0 8px 40px rgba(0,0,0,.35); }
    *{ box-sizing:border-box; } html,body{ height:100%; } body{
      margin:0; font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(76,227,184,.08), transparent 60%),
        radial-gradient(1400px 800px at 120% -20%, rgba(156,240,215,.06), transparent 60%),
        var(--bg);
      color:var(--ink); line-height:1.6;
    }
    header{ position:sticky; top:0; z-index:10; backdrop-filter: blur(8px) saturate(120%); background: rgba(9,12,18,.65); border-bottom:1px solid var(--line); }
    .container{ max-width:1100px; margin:0 auto; padding: clamp(16px,2vw,28px); }
    .hero{ display:grid; grid-template-columns: 1.15fr .85fr; gap: clamp(16px,2.5vw,28px); align-items:center; }
    @media (max-width:980px){ .hero{ grid-template-columns:1fr; } }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:18px; padding: clamp(14px,1.8vw,22px); box-shadow:var(--shadow); }
    .hero-img, figure{ position:relative; border-radius:18px; overflow:hidden; border:1px solid var(--line); }
    .hero-img{ aspect-ratio:4/3; } figure{ aspect-ratio:1/1; margin:0; }
    img{ width:100%; height:100%; object-fit:cover; display:block; }
    h1{ font-size: clamp(1.6rem, 2.6vw + 1rem, 2.6rem); margin:.4rem 0 .2rem; }
    .lead{ color:var(--muted); }
    .gallery{ display:grid; gap:12px; grid-template-columns: repeat(3, minmax(0,1fr)); }
    @media (max-width:980px){ .gallery{ grid-template-columns:1fr; } }
    .regen{ position:absolute; right:8px; bottom:8px; border:1px solid #244; background: rgba(0,0,0,.55); color:#cfe; border-radius:999px; padding:6px 10px; font-size:.85rem; display:none; cursor:pointer; }
    .note{ color:var(--muted); }
  </style>
</head>
<body>
<header><div class="container"><strong>Minimal, Honest Sourdough</strong> — images self‑heal with a 3D loaf</div></header>

<main class="container">
  <section class="hero">
    <div>
      <h1>Most Delicious Sourdough at Home</h1>
      <p class="lead">Utensil specifics (Dutch‑oven lid timing), oven modes (conventional vs fan‑forced), starter storage & aromas. If a photo fails, a <strong>3D‑rendered sourdough</strong> is drawn instantly. The “Regenerate” button only appears after a failure.</p>
    </div>
    <figure class="hero-img">
      <img class="watch" alt="Crusty rustic sourdough loaf on board"
           src="https://images.unsplash.com/photo-1600326145359-9bb9282b3d48?q=80&w=1600&auto=format&fit=crop" referrerpolicy="no-referrer">
      <button class="regen" aria-label="Regenerate 3D loaf">Regenerate</button>
    </figure>
  </section>

  <section class="card" style="margin-top:18px;">
    <h2>Rustic Gallery</h2>
    <div class="gallery">
      <figure>
        <img class="watch" alt="Decorative scoring"
             src="https://images.unsplash.com/photo-1589367920969-ab8e050bbb04?q=80&w=800&auto=format&fit=crop" referrerpolicy="no-referrer">
        <button class="regen" aria-label="Regenerate 3D loaf">Regenerate</button>
      </figure>
      <figure>
        <img class="watch" alt="Loaf cooling on rack"
             src="https://images.unsplash.com/photo-1514516870926-2059896c1c78?q=80&w=800&auto=format&fit=crop" referrerpolicy="no-referrer">
        <button class="regen" aria-label="Regenerate 3D loaf">Regenerate</button>
      </figure>
      <figure>
        <img class="watch" alt="Rustic crumb close-up"
             src="https://images.unsplash.com/photo-1549931319-a545dcf3bc73?q=80&w=800&auto=format&fit=crop" referrerpolicy="no-referrer">
        <button class="regen" aria-label="Regenerate 3D loaf">Regenerate</button>
      </figure>
    </div>
    <p class="note">If an image fails, a 3D fallback will render and you’ll get a “Regenerate” button to make another loaf.</p>
  </section>
</main>

<script>
// ===== Tiny WebGL raymarcher to render a 3D sourdough loaf (ellipsoid) on a wood board =====
function render3DLoaf(width, height, seed){
  const c = document.createElement('canvas'); c.width = width; c.height = height;
  const gl = c.getContext('webgl', {preserveDrawingBuffer:true});
  if(!gl){ return null; }

  const vsrc = `
    attribute vec2 p; void main(){ gl_Position = vec4(p,0.0,1.0); }
  `;
  const fsrc = `
    precision highp float;
    uniform vec2  uRes;
    uniform float uTime;
    uniform float uSeed;

    // hash / RNG
    float hash(float n){ return fract(sin(n)*43758.5453123); }
    float n2(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453); }

    // Signed distance functions
    float sdEllipsoid(vec3 p, vec3 r){
      // approximate SDF for ellipsoid
      float k0 = length(p / r);
      float k1 = length(p / (r*r));
      return k0*(k0-1.0)/k1;
    }
    float sdPlane(vec3 p){ return p.y; } // plane at y=0

    // scene SDF
    struct S { float d; int id; };
    S scene(vec3 p){
      // plane (wood board) at y=0
      float dPlane = sdPlane(p);
      // loaf ellipsoid above plane
      vec3 rp = p - vec3(0.0, 0.28, 0.0);
      float dLoaf = sdEllipsoid(rp, vec3(0.55, 0.28, 0.4));
      S s;
      if(dLoaf < dPlane){ s.d = dLoaf; s.id = 1; } else { s.d = dPlane; s.id = 2; }
      return s;
    }

    // Raymarch
    vec3 rayDir(float fov, vec2 size, vec2 fragCoord){
      vec2 xy = fragCoord - size*0.5;
      float z = size.y / tan(radians(fov)*0.5);
      return normalize(vec3(xy, -z));
    }

    S march(vec3 ro, vec3 rd){
      float t = 0.0;
      int id = 0;
      for(int i=0;i<128;i++){
        vec3 p = ro + rd*t;
        S s = scene(p);
        if(s.d < 0.001){ id = s.id; break; }
        t += s.d;
        if(t > 10.0) break;
        id = s.id;
      }
      S outS; outS.d = t; outS.id = id; return outS;
    }

    vec3 calcNormal(vec3 p){
      float e = 0.001;
      vec2 h = vec2(1.0, -1.0)*0.5773;
      return normalize( h.xyy*scene(p + h.xyy*e).d +
                        h.yyx*scene(p + h.yyx*e).d +
                        h.yxy*scene(p + h.yxy*e).d +
                        h.xxx*scene(p + h.xxx*e).d );
    }

    // crust color + scoring
    float stripe(vec3 p){
      // arc-like scoring on top
      float a = atan(p.z, p.x);
      float r = length(p.xz);
      float band = smoothstep(0.12, 0.11, abs(r - 0.2 + 0.02*sin(a*3.0)));
      return band;
    }

    float noise(vec3 p){
      // simple layered noise
      float n = 0.0, a = 0.5;
      for(int i=0;i<4;i++){ n += a * n2(p.xz*3.0 + float(i)); p *= 1.7; a *= 0.5; }
      return n;
    }

    void main(){
      vec2 uv = gl_FragCoord.xy;
      vec3 ro = vec3(0.0, 0.25, 1.7);
      vec3 rd = rayDir(45.0, uRes, uv);
      // aim camera slightly down
      rd = normalize(mat3(
        1.0, 0.0, 0.0,
        0.0, 0.97, -0.26,
        0.0, 0.26,  0.97
      ) * rd);

      S m = march(ro, rd);
      vec3 col = vec3(0.0);
      vec3 p = ro + rd*m.d;

      vec3 L = normalize(vec3(0.7, 1.2, 0.6));
      vec3 V = normalize(-rd);

      if(m.d < 10.0){
        vec3 N = calcNormal(p);
        float diff = max(dot(N,L), 0.0);
        float spec = pow(max(dot(reflect(-L, N), V), 0.0), 32.0);

        if(m.id == 1){
          // loaf shading
          vec3 lp = p - vec3(0.0, 0.28, 0.0);
          float flour = smoothstep(0.15, 0.5, 1.0 - length(lp*vec3(1.0,1.2,1.0)));
          float crustNoise = noise(lp*2.0 + uSeed);
          float score = stripe(lp);

          vec3 base = mix(vec3(0.33,0.19,0.09), vec3(0.62,0.40,0.18), 0.6 + 0.4*crustNoise);
          base = mix(base, vec3(0.95,0.92,0.85), flour*0.8);               // flour dusting
          base = mix(base, vec3(0.98,0.94,0.88), score);                    // scoring lighter
          col = base * (0.25 + 0.9*diff) + 0.15*spec;
        } else {
          // board shading
          float wood = 0.08 + 0.12*sin(p.x*20.0 + uSeed*1.7) + 0.05*sin(p.z*13.0);
          col = vec3(0.18,0.12,0.08) + wood;
          col *= (0.4 + 0.6*diff);
        }

        // ambient occlusion-ish
        col *= 0.9 + 0.1*exp(-0.7*m.d);
      }

      // vignette
      vec2 q = uv/uRes;
      float vig = 0.65 + 0.35*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25);
      col *= vig;

      gl_FragColor = vec4(col,1.0);
    }
  `;

  function compile(src, type){
    const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ console.warn(gl.getShaderInfoLog(s)); return null; }
    return s;
  }
  const vs = compile(vsrc, gl.VERTEX_SHADER);
  const fs = compile(fsrc, gl.FRAGMENT_SHADER);
  if(!vs || !fs){ return null; }
  const prog = gl.createProgram(); gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){ console.warn(gl.getProgramInfoLog(prog)); return null; }
  gl.useProgram(prog);

  // fullscreen triangle
  const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
  const loc = gl.getAttribLocation(prog, 'p'); gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

  gl.viewport(0,0,width,height);
  gl.uniform2f(gl.getUniformLocation(prog,'uRes'), width, height);
  gl.uniform1f(gl.getUniformLocation(prog,'uTime'), performance.now()/1000.0);
  gl.uniform1f(gl.getUniformLocation(prog,'uSeed'), (seed||0.0));

  gl.drawArrays(gl.TRIANGLES, 0, 3);

  try{ return c.toDataURL('image/png'); }catch(e){ return null; }
}

// ---- Self-healing logic ----
// Show "Regenerate" only AFTER a failure triggered 3D fallback.
function attachSelfHealing(wrapper){
  const img = wrapper.querySelector('img.watch');
  const btn = wrapper.querySelector('button.regen');

  function fallback(){
    const r = img.getBoundingClientRect();
    const w = Math.max(600, Math.floor(r.width||800));
    const h = Math.max(400, Math.floor((r.height||w*0.75)));
    const seed = Math.floor(Math.random()*1e6);
    const data = render3DLoaf(w, h, seed);
    if(data){
      img.src = data;
      btn.style.display = 'inline-flex'; // button appears only now
    }else{
      // As ultimate fallback, draw a simple canvas-based 2D loaf
      const c = document.createElement('canvas'); c.width = w; c.height = h;
      const ctx = c.getContext('2d'); ctx.fillStyle = '#0b0f14'; ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#3a2a1f'; ctx.fillRect(0,h*0.8,w,h*0.2);
      ctx.fillStyle = '#c68642'; ctx.beginPath(); ctx.ellipse(w*0.5,h*0.7,w*0.28,h*0.18,0,0,Math.PI*2); ctx.fill();
      img.src = c.toDataURL('image/png');
      btn.style.display = 'inline-flex';
    }
  }

  img.addEventListener('error', function(){ fallback(); }, { once:true });
  img.addEventListener('load', function(){
    // Some blocked images "load" but have zero dimensions; swap them.
    if(!img.naturalWidth || !img.naturalHeight){ fallback(); }
  });

  btn.addEventListener('click', function(){
    // Regenerate only after failure
    fallback();
  });
}

document.querySelectorAll('.hero-img, .gallery figure').forEach(attachSelfHealing);
</script>
</body>
</html>
